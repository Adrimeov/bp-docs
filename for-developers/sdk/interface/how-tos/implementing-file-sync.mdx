---
title: Implementing unidirectional file synchronization in an integration
---

import { FileSynchronizerIcon } from '/snippets/icons/plugins/file-synchronizer.mdx'
import { CurrentInterfaceVersion } from '/snippets/interface-version.mdx'
import { DefinitionList, Definition, DefinitionReference as Term } from '/snippets/definition-list.mdx'

<p>
  <FileSynchronizerIcon width={64} style={{float: 'left', marginRight: 15}} role="presentation" />
  The unidirectional file synchronization interface allows you to implement 1-way sync in your integration to import files from an external service to Botpress.
</p>

## Filesystem abstraction

The file synchronization interface provides a filesystem-like abstraction that works with any kind of data source. The external service doesn't need to provide an actual filesystem - your integration just needs to represent the external data as files and folders.

For example:
- If you are building a website crawler, individual pages could be folders and HTML contents and assets like images or stylesheets could be files.
- For a notetaking platform, notebooks could be folders with individual notes being files.
- For an email provider, mailboxes or labels could be folders and individual emails could be files.

This abstraction allows the interface to work consistently regardless of what type of data is being synchronized from your external service.

## Terminology

Throughout this document, we will use the following terms:

<DefinitionList>
  <Definition term="integration" id="integration">
    The code that connects Botpress to an external service.
  </Definition>
  <Definition term="external service" id="external-service">
    The service from which you want to import files. This could be a cloud storage service, a file server, or any other type of external service that stores files.
  </Definition>
  <Definition term="file synchronization interface" id="files-readonly">
    The interface that defines the contract for implementing unidirectional file synchronization in your integration. This interface specifies the actions and events that your integration must implement to support file synchronization.
  </Definition>
  <Definition term="file synchronizer plugin" id="file-synchronizer">
    The Botpress plugin that orchestrates file synchronization. This plugin is responsible for managing the synchronization process, including scheduling, error handling, and reporting.
  </Definition>
  <Definition term="file" id="file">
    A file is a single unit of data that can be synchronized from the external service to Botpress. Files can contain any type of data, such as text, images, or binary data. Files _cannot_ contain other files or folders.
  </Definition>
  <Definition term="folder" id="folder">
    A folder is a container for files. Folders can contain other folders and files, allowing for a hierarchical organization of data.
  </Definition>
  <Definition term="real-time synchronization" id="real-time-sync">
    A synchronization mode where changes in the external service are immediately reflected in Botpress. This is typically achieved through webhooks or other push mechanisms. Integrations are not required to support this mode, but it is recommended for better user experience.
  </Definition>
</DefinitionList>

## External service requirements

The <Term id="external-service"/> providing file synchronization functionality **must** support the following:
- An API that allows listing all files and folders in a folder.
- An API that allows downloading files.

The <Term id="external-service"/> **may** also support the following in order to provide <Term id="real-time-sync"/>:
- Webhooks that can notify your <Term id="integration"/> of the following events:
  - A <Term id="file"/> was created.
  - A <Term id="file"/> was updated.
  - A <Term id="file"/> was deleted.
  - A <Term id="folder"/> was deleted.

## Updating your `package.json` file

### Finding the current interface version

The current version of the `files-readonly` interface is: <code>^<CurrentInterfaceVersion interfaceName="files-readonly" fallback="0.2.0" /></code>

You will need this version number for the next steps.

### Adding the interface as a dependency

Once you have the <Term id="files-readonly"/> version, you can add it as a dependency to your <Term id="integration"/>:

<Steps>
  <Step title="Open the package.json file">
    Open your <Term id="integration"/>'s `package.json` file.
  </Step>
  <Step title="Add the bpDependencies section">
    If there is no `bpDependencies` section in your <Term id="integration"/>'s `package.json` file, create one:
    ```json package.json {2}
    {
      "bpDependencies": {}
    }
    ```
  </Step>
  <Step title="Add the interface as a dependency">
    In the `bpDependencies` section, add the <Term id="files-readonly"/> as a dependency. For example, for version `0.2.0`, you would add the following:
    ```json package.json {3}
    {
      "bpDependencies": {
        "files-readonly": "interface:files-readonly@^0.2.0"
      }
    }
    ```
    <Warning>
    It is very important to follow this syntax: <br/>
    `"<interface-name>": "interface:<interface-name>@<version>"`.
    </Warning>
    <Tip>
    Interface versions use a numbering system with three parts: MAJOR.MINOR.PATCH (like `1.2.3`). When adding an interface to your integration, we recommend using the caret symbol (`^`) before the version number (like `^0.2.0`). This tells the Botpress CLI to automatically use newer compatible versions when they're available.

    For example, if you specify `^0.2.0` as the version:
    - You'll automatically get updates like `0.2.6` or `0.3.0` (bug fixes and new features).
    - You won't get version `1.0.0` (which might break your <Term id="integration"/>).
    </Tip>
  </Step>
  <Step title="Save the package.json file">
    Save the `package.json` file.
  </Step>
  <Step title="Install the interface">
  Now that you have added the <Term id="files-readonly"/> as a dependency, you can run the [`bp add`](/for-developers/cli/commands/add) command to install it. This command will:
  - Download the interface from Botpress.
  - Install it in a directory named `bp_modules` in your <Term id="integration"/>'s root directory.
  </Step>
</Steps>

### Adding a helper build script

To keep your <Term id="integration"/> up to date, we recommend adding a helper build script to your `package.json` file:

<Steps>
  <Step title="Open the package.json file">
    Open your <Term id="integration"/>'s `package.json` file.
  </Step>
  <Step title="Add the build script">
    In the `scripts` section, add the following script:
    ```json package.json {3}
    {
      "scripts": {
        "build": "bp add -y && bp build"
      }
    }
    ```
    <Note>
    If the `build` script already exists in your `package.json` file, please replace it.
    </Note>
  </Step>
  <Step title="Save the package.json file">
    Save the `package.json` file.
  </Step>
</Steps>

Now, whenever you run `npm run build`, it will automatically install the <Term id="files-readonly" /> and build your <Term id="integration" />. This is useful for ensuring that your <Term id="integration"/> is always up to date with the latest version of the <Term id="files-readonly"/>.

## Editing your integration definition file

### Adding the interface to your integration definition file

Now that the <Term id="files-readonly"/> is installed, you must add it your integration definition file in order to implement it.

<Steps>
  <Step title="Open the integration.definition.ts file">
    Open your <Term id="integration"/>'s `integration.definition.ts` file.
  </Step>
  <Step title="Import the interface">
    At the top of the file, import the <Term id="files-readonly"/>:
    ```typescript integration.definition.ts
    import filesReadonly from './bp_modules/files-readonly'
    ```
  </Step>
  <Step title="Extend your definition">
  Use the `.extend()` function at the end of your `new IntegrationDefinition()` statement:
  ```typescript integration.definition.ts {4-6}
  export default new sdk.IntegrationDefinition({
    ...
  })
    .extend(files-readonly, () => ({
      entities: {},
    }))
  ```
  The exact syntax of `.extend()` will be explained in the next section.
  </Step>
</Steps>

### Configuring the interface

The `.extend()` function takes two arguments:

- The first argument is a reference to the interface you want to implement. In this case, it is `filesReadonly`.
- The second argument is a configuration object. Using this object, you can override interface defaults with custom names, titles, and descriptions.

<Tip>
Whilst renaming actions, events and channels is optional, it is highly recommended to rename these to match the terminology of the <Term id="external-service"/>. This will help you avoid confusion and make your <Term id="integration"/> easier to understand.
</Tip>

#### Renaming actions

The <Term id="files-readonly"/> defines two actions that are used to interact with the <Term id="external-service"/>:

- `listItemsInFolder` - Used by the <Term id="file-synchronizer"/> to request a list of all files and folders in a folder.
- `transferFileToBotpress` - Used by the <Term id="file-synchronizer"/> to request that a file be downloaded from the <Term id="external-service"/> and uploaded to Botpress.

If you want to rename these actions, you can do so in the configuration object. For example, if you want to rename `listItemsInFolder` to `crawlFolder`, you can do it like this:

```typescript integration.definition.ts {4}
.extend(filesReadonly, () => ({
  actions: {
    listItemsInFolder: {
      name: 'crawlFolder',
    },
  },
}))
```

<Tip>
For example, if you're using a notetaking platform such as Microsoft OneNote, you might rename `listItemsInFolder` to `listNotebooksAndPages` and `transferFileToBotpress` to `downloadPage`. This way, the action names reflect the specific context of the notetaking platform, making your <Term id="integration"/> clearer and easier to understand.
</Tip>

#### Renaming events

The <Term id="files-readonly"/> interface defines these events to notify the plugin of changes in the <Term id="external-service"/>:

- `fileCreated` - Emitted by your <Term id="integration"/> to notify the <Term id="file-synchronizer"/> that a new <Term id="file"/> has been created in the <Term id="external-service"/>.
- `fileUpdated` - Emitted by your <Term id="integration"/> to notify the <Term id="file-synchronizer"/> that a <Term id="file"/> has been updated in the <Term id="external-service"/>.
- `fileDeleted` - Emitted by your <Term id="integration"/> to notify the <Term id="file-synchronizer"/> that a <Term id="file"/> has been deleted in the <Term id="external-service"/>.
- `folderDeletedRecursive` - Emitted by your <Term id="integration"/> to notify the <Term id="file-synchronizer"/> that a <Term id="folder"/> and all of its contents have been deleted in the <Term id="external-service"/>.

<Tip>
If the <Term id="external-service"/> emits several filesystem changes at once, it is also possible for your integration to emit a `aggregateFileChanges` event, which contains all the changes in a single event.
</Tip>

If you want to rename these events, you can do so in the configuration object. For example, if you want to rename `fileCreated` to `pageCreated`, you can do it like this:

```typescript integration.definition.ts {4}
.extend(filesReadonly, () => ({
  events: {
    fileCreated: {
      name: 'pageCreated',
    },
  },
}))
```

## Implementing the interface

### Implementing the actions

TODO

### Implementing real-time sync

TODO
